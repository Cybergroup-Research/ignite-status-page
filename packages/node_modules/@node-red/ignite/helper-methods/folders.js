var fse = require('fs-extra');
const fs = require('fs');
const fsp = fs.promises;
const { promisify } = require("util");
var archiver = require('archiver');
const StreamZip = require('node-stream-zip');

async function getLocalFolderInBase64(archivedFolderBuffer) {
    try {
        return archivedFolderBuffer.toString('base64');
    }
    catch (e) {
        console.error('getLocalFolderInBase64() - Unable to convert to base64', e);
        return null;
    }
}

/** if false is passed for destpath, the path of a chunk of data in the archive is set to the root */
async function archiveFolder(dirnames, fileNames, directoryDestPath) {
    try {
        // let createWriteStream = promisify(fs.createWriteStream);
        // let readStream = promisify(fs.ReadStream);

        let archivedDataBinary = [];

        directoryDestPath = directoryDestPath || false;

        var archive = archiver('zip', {
            zlib: { level: 9 } // Sets the compression level.
        }).on('data', data => archivedDataBinary.push(data));

        if (Array.isArray(dirnames) && dirnames.length >= 1) {
            for (var dirname of dirnames) {
                await archive.directory(dirname, directoryDestPath);
            }
        }
        else if (!Array.isArray(dirnames) && typeof dirnames === 'string' && dirnames) {
            await archive.directory(dirnames, directoryDestPath);
        }
        else {
            dirnames = false;
        }

        if (Array.isArray(fileNames) && fileNames.length >= 1) {
            for (var filename of fileNames) {
                await archive.file(filename);
            }
        }
        else if (!Array.isArray(fileNames) && typeof fileNames === 'string' && fileNames) {
            await archive.file(fileNames);
        }
        else {
            fileNames = false;
        }

        if (!dirnames && !fileNames) {
            console.warn("archiveFolder() - null or empty dirnames and/or fileNames were passed into the function");
            return null;
        }

        // pipe archive data to the file
        //archive.pipe(output);

        await archive.finalize();

        console.log('Finished Archiving');

        let zipData = Buffer.concat(archivedDataBinary);

        return zipData;
    }
    catch (e) {
        console.error(`archiveFolder() - Unable to archieve folder: ${dirname}`, e);
        return null;
    }
}

async function createZippedFolder(zipFolderLocation, zipData) {
    try {
        let byteArray = new Uint8Array(zipData);

        var buffer = new Buffer(byteArray.length);

        for (var i = 0; i < byteArray.length; i++) {

            buffer.writeUInt8(byteArray[i], i);
        }

        await fsp.writeFile(zipFolderLocation, buffer);

        console.log(`Created ${zipFolderLocation}`);
        return true;
    }
    catch (e) {
        console.error(`createZippedFolder() - unable to zip folder: ${zipFolderLocation}`, e);
        return false;
    }
}

/** if files are not saved to root folder of zip file then set extractFromSubFolders argument to true and also pass the name of the folder to extract in zip*/
async function unzipFolder(extractFromFolder, extractToFolder, extractFromSubFolders, folderNameToExtractInZip) {

    await fsp.mkdir(extractToFolder, { recursive: true });

    console.log(`Extracting data from ${extractFromFolder} to root folder of project.....`);

    return new Promise((resolve, reject) => {
        try {
            const zip = new StreamZip({
                file: extractFromFolder,
                storeEntries: true
            });
            
            let pathOfFolderToExtractInZip = null;

            zip.on('ready', () => {

                if (extractFromSubFolders) {
                    for (const entry of Object.values(zip.entries())) {
                        pathOfFolderToExtractInZip = entry.name.substring(0, entry.name.lastIndexOf(folderNameToExtractInZip) + folderNameToExtractInZip.length);
                        break;
                    }
                }

                zip.extract(pathOfFolderToExtractInZip, extractToFolder, (err, count) => {
                    if (err) {
                        console.error("unzipFolder() - zip.extract - Extract error", err);
                        return resolve(false);
                    }
                    console.log(`Extracted ${count} entries,Folder was successfully un-zipped`);
                    zip.close();
                    resolve(true);
                });
            });
        }
        catch (e) {
            console.error("unzipFolder() - unable to unzip folder", e);
            return resolve(false);
        }
    });
}

/** Asynchronously writes data to a file, replacing the file if it already exists. */
async function writeToAFile(path, data) {

    if (!doesFileOrFolderExists(path)) {
        console.log(`File doesn't exists, path = ${path}`);
        return null;
    }

    await fsp.writeFile(path, data);
}

/** removes a file or folder if exists */
async function removeFolderOrFile(isCreated, folderPath) {

    //if isCreated is false then to be sure, just check one more time if the folder exists
    if (!isCreated) {
        isCreated = await fse.pathExists(folderPath);
    }

    if (isCreated) {
        fse.remove(folderPath);
        console.log(`removed ${folderPath}`);
    }
}

/** creates a folder if not exists */
async function createFolder(folderPath) {
    await fsp.mkdir(folderPath, { recursive: true });
}

/** creates a file if not exists */
async function createFile(filePath) {
    if (!fs.existsSync(filePath)) {
        console.log(`Created file ${filePath}`);
        await fse.createFile(filePath)
        return;
    }
    console.log(`File ${filePath} already exists`);
}

/** reads all the content of the file */
async function readFile(folderPath) {
    return await fsp.readFile(folderPath, 'utf8');
}

/** check if file or folder exists */
async function doesFileOrFolderExists(filePath) {
    return fs.existsSync(filePath);
}

/** check if the requested path is a folder */
async function isPathAFolder(filePath) {
    if (!filePath) {
        return false;
    }

    let stat = await fse.lstat(filePath);
    return stat.isDirectory();
}

/** check if the requested path is a file */
async function isPathAFile(filePath) {
    if (!filePath) {
        return false;
    }

    let stat = await fse.lstat(filePath);
    return stat.isFile();
}

module.exports = {
    archiveFolder: archiveFolder,
    createZippedFolder: createZippedFolder,
    unzipFolder: unzipFolder,
    removeFolderOrFile: removeFolderOrFile,
    getLocalFolderInBase64: getLocalFolderInBase64,
    createFolder: createFolder,
    createFile: createFile,
    readFile: readFile,
    doesFileOrFolderExists: doesFileOrFolderExists,
    writeToAFile: writeToAFile,
    isPathAFolder,
    isPathAFile
};

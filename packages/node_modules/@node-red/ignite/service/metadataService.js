const dbRepo = require('../database-operations/repository/databaseRepository');
const folders = require('../helper-methods/folders');
const chokidar = require('chokidar');
const fs = require('fs');

var path = require("path");

class MetadataService {

    constructor() {
        dbRepo.init();
        this._homePath = process.env.IGNITE_HOME_PATH;
        this._rootFolderPath = process.env.PROJECT_ROOT_FOLDER_PATH;
    }

    async saveConfigJsonInDB() {
        try {
            console.log(`Archiving Config file`);

            let configFilePath = path.join(this._homePath, ".config.json");
            let configBackupFilePath = path.join(this._homePath, ".config.json.backup");
            let filePaths = [configFilePath, configBackupFilePath];

            let archivedFolderBuffer = await folders.archiveFolder(null, filePaths, true);

            if (!archivedFolderBuffer) {
                console.warn("MetadataService - saveConfigJsonInDB() - files were not archived");
                return "";
            }

            let archivedFolderBase64Buffer = await folders.getLocalFolderInBase64(archivedFolderBuffer);

            if (!archivedFolderBase64Buffer) {
                return "";
            }

            console.log(`Saving in db`);
            let result = await dbRepo.saveBufferConfigInDB(archivedFolderBase64Buffer, true);

            return result;
        }
        catch (e) {
            console.error('MetadataService - saveConfigFolderInDB() - Unable to save Config folder in DB', e);
            return false;
        }
    }

    async savePackagesInDB() {
        try {
            console.log('Archiving package json');

            let packageFilePath = path.join(this._homePath, "package.json");
            let packageLockFilePath = path.join(this._homePath, "package-lock.json");

            let archivedFolderBuffer = await folders.archiveFolder(null, [packageFilePath, packageLockFilePath], true);

            if (!archivedFolderBuffer) {
                console.warn("MetadataService - savePackagesInDB() - package json were not archived");
                return "";
            }

            let archivedFolderBase64Buffer = await folders.getLocalFolderInBase64(archivedFolderBuffer);

            if (!archivedFolderBase64Buffer) {
                return "";
            }

            console.log(`Saving in db`);
            let result = await dbRepo.saveBufferPackagesInDB(archivedFolderBase64Buffer, true);

            return result;
        }
        catch (e) {
            console.error('MetadataService - savePackagesInDB() - Unable to save package json in DB', e);
            return false;
        }
    }

    async saveNodeModulesInDB() {
        try {
            console.log(`Archiving node_modules folder`);

            let nodeModulesFolderPath = path.join(this._homePath, "node_modules");

            let archivedFolderBuffer = await folders.archiveFolder(nodeModulesFolderPath, null, true);

            if (!archivedFolderBuffer) {
                console.warn("MetadataService - saveNodeModulesInDB() - folder was not archived");
                return "";
            }

            let archivedFolderBase64Buffer = await folders.getLocalFolderInBase64(archivedFolderBuffer);

            if (!archivedFolderBase64Buffer) {
                return "";
            }

            console.log(`Saving in db`);
            let result = await dbRepo.saveBufferNodeModulesInDB(archivedFolderBase64Buffer, true);

            return result;
        }
        catch (e) {
            console.error('MetadataService - saveConfigFolderInDB() - Unable to save node_modules folder in DB', e);
            return false;
        }
    }

    async saveFunctionsInDB() {
        try {
            console.log('Archiving lib folder');

            let libFolderPath = path.join(this._homePath, "lib");

            let archivedFolderBuffer = await folders.archiveFolder(libFolderPath, null, false);

            if (!archivedFolderBuffer) {
                console.warn("MetadataService - saveFunctionsInDB() - folder was not archived");
                return "";
            }

            let archivedFolderBase64Buffer = await folders.getLocalFolderInBase64(archivedFolderBuffer);

            if (!archivedFolderBase64Buffer) {
                return "";
            }

            console.log(`Saving in db`);
            let result = await dbRepo.saveBufferLibInDB(archivedFolderBase64Buffer, false);

            return result;
        }
        catch (e) {
            console.error('MetadataService - saveConfigFolderInDB() - Unable to save node_modules folder in DB', e);
            return false;
        }
    }


    async restoreMetaDataFiles() {
        let homePath = this._homePath;
        let isCreated = false;

        try {
            console.log('Checking if metadata details are available in igniteMetadata table or not');
            let result = await dbRepo.getIgniteMetaDataFromDB();

            if (!result || Array.isArray(result) && result.length === 0) {
                console.warn('MetadataService - restoreMetaDataFiles() - Ignite metadata not found in the DB');
                return false;
            }

            await folders.createFolder(homePath);

            let unzipResult = await Promise.all(result.map(async (x, index) => {

                let extractToFolderPath = homePath;
                let response = { metadataname: x.metadataname, result: false };

                let zipFolderPath = path.join(homePath, `${x.metadataname}.zip`);

                if (x.metadataname === 'lib' && !x.extractfromsubfolders) {
                    extractToFolderPath = path.join(homePath, x.metadataname);
                }

                let folderBufferBase64 = x.folderdetails;

                if (!folderBufferBase64) {
                    console.warn(`MetadataService - restoreMetaDataFiles() - ${x.metadataname} folder metadata not found in DB`);
                    return response;
                }

                console.log(`${x.metadataname} folder metadata found in DB,Restoring ${x.metadataname} folder`);

                let archivedFolderBuffer = Buffer.from(folderBufferBase64, 'base64');

                isCreated = await folders.createZippedFolder(zipFolderPath, archivedFolderBuffer);

                if (!isCreated) {
                    console.error('MetadataService - restoreMetaDataFiles() - Unable to create Zipped Folder for metadata folders');
                    return response;
                }

                let isUnzipped = await folders.unzipFolder(zipFolderPath, extractToFolderPath, x.extractfromsubfolders, ".node-red");

                if (!isUnzipped) {
                    return response;
                }

                console.log(`${x.metadataname} was successfully restored`);

                folders.removeFolderOrFile(isCreated, zipFolderPath);

                response.result = isUnzipped;
                return response;
            }));

            return unzipResult;
        }
        catch (e) {
            console.error('MetadataService - restoreMetaDataFiles() - Unable to restore metadata folders', e);
            return false;
        }
    }

    async readConfigFile() {
        try {
            let configFilePath = path.join(this._homePath, ".config.json");

            var data = await folders.readFile(configFilePath);

            if (!data) {
                console.warn("MetadataService - readConfigFile() - Data is not available in config file");
                return null;
            }
            return JSON.parse(data);
        }
        catch (e) {
            console.error('MetadataService - readConfigFile() - Unable to read data from config file', e);
            return null;
        }
    }

    async watchConfigFile() {
        var self = this;

        let configFilePath = path.join(this._homePath, ".config.json");

        await folders.createFile(configFilePath);

        const watcher = chokidar.watch(configFilePath, { persistent: true });

        console.log("Started watching Config File");

        watcher.on('change', async filePath => {
            if (process.env.IS_APPLICATION_LOADED === "true") {
                console.log("Watching Config File");
                await self.saveConfigJsonInDB();
            }
        });
    }

    async watchPackageLockFile() {
        var self = this;

        let packageLockPath = path.join(this._homePath, "package-lock.json");

        await folders.createFile(packageLockPath);

        const watcher = chokidar.watch(packageLockPath, { persistent: true });

        console.log("Started watching package-Lock json");

        watcher.on('change', async filePath => {
            if (process.env.IS_APPLICATION_LOADED === "true") {
                console.log("Watching package-Lock json");
                await self.savePackagesInDB();
                await self.saveNodeModulesInDB();
            }
        });
    }

    async watchPackageFile() {
        var self = this;

        let packagePath = path.join(this._homePath, "package.json");

        if (!await folders.doesFileOrFolderExists(packagePath)) {
            console.log("Package.json not found");
            await folders.writeToAFile(packagePath, '{"name": "Ignite","description": "A Cyber Group Project","version": "1.0.7"}');
            console.log("Created package.json");
        }

        const watcher = chokidar.watch(packagePath, { persistent: true });

        console.log("Started watching package json");

        watcher.on('change', async filePath => {
            if (process.env.IS_APPLICATION_LOADED === "true") {
                console.log("Watching package json");
                await self.savePackagesInDB();
            }
        });
    }

    async watchLibFolder() {
        var self = this;

        let libPath = path.join(this._homePath, "lib");

        await folders.createFolder(libPath);

        const watcher = chokidar.watch(libPath, { persistent: true });

        console.log("Started watching lib Folder");

        watcher.on('change', async filePath => {
            if (process.env.IS_APPLICATION_LOADED === "true") {
                console.log("Watching lib Folder");
                await self.saveFunctionsInDB();
            }
        }).on('add', async filePath => {
            if (process.env.IS_APPLICATION_LOADED === "true") {
                console.log("Watching lib File");
                await self.saveFunctionsInDB();
            }
        }).on('unlink', async filePath => {
            if (process.env.IS_APPLICATION_LOADED === "true") {
                console.log("Watching lib File");
                await self.saveFunctionsInDB();
            }
        });
    }

    async watchNodeModulesFolder() {

        let nodeModulesPath = path.join(this._homePath, "node_modules");

        fs.watch(nodeModulesPath, function (event, filename) {
            if (event.toString().includes('change')) {
                self.watchPackageLockFolder();
            }
        });
    }
}

export default MetadataService;
const dbRepo = require('../database-operations/repository/databaseRepository');
const folders = require('../helper-methods/folders');

var path = require("path");

class ProjectsService {

    constructor() {
        dbRepo.init();
        this._homePath = process.env.IGNITE_HOME_PATH;
        this._rootFolderPath = process.env.PROJECT_ROOT_FOLDER_PATH;
    }

    async saveProjectsFolderInDB() {
        try {
            console.log(`Archiving Projects Folder`);

            let projectFolderPath = path.join(this._homePath, "projects");

            let archivedFolderBuffer = await folders.archiveFolder(projectFolderPath, null, false);

            if (!archivedFolderBuffer) {
                console.warn("ProjectsService - saveProjectsFolderInDB() - folders were not archived");
                return "";
            }

            let archivedFolderBase64Buffer = await folders.getLocalFolderInBase64(archivedFolderBuffer);

            if (!archivedFolderBase64Buffer) {
                return "";
            }

            console.log(`Saving in db`);
            let result = await dbRepo.saveBinaryProjectsInDB(archivedFolderBase64Buffer);

            return result;
        }
        catch (e) {
            console.error('ProjectsService - saveProjectsFolderInDB() - Unable to save projects folder in DB', e);
            return false;
        }
    }

    async saveSSHKeyFolderInDB() {
        try {
            console.log(`Archiving .ssh Folder`);

            let sshFolderPath = path.join(this._rootFolderPath, ".ssh");
            let archivedFolderBuffer = await folders.archiveFolder(sshFolderPath, null, false);

            if (!archivedFolderBuffer) {
                console.warn("saveSSHKeyFolderInDB() - .ssh key folder was not archived");
                return "";
            }

            let archivedFolderBase64Buffer = await folders.getLocalFolderInBase64(archivedFolderBuffer);

            if (!archivedFolderBase64Buffer) {
                return "";
            }

            console.log(`Saving in db`);
            let result = await dbRepo.saveBinarySSHInDB(archivedFolderBase64Buffer);

            return result;
        }
        catch (e) {
            console.error('ProjectsService - saveSSHKeyFolderInDB() - Unable to save ssh folder in DB', e);
            return false;
        }
    }

    async restoreProjectsFolder() {
        let zipFolderPath = path.join(this._homePath, "projects.zip");
        let extractToFolderPath = path.join(this._homePath, "projects");
        let isCreated = false;

        try {
            console.log('Checking if Project details are available in projectDetails table or not');
            let result = await dbRepo.getProjectsFromDB();

            if (result == null || !result) {
                await this.createSshFolder();
                console.warn('ProjectsService - restoreProjectsFolder() - Projects folder metadata not found in the DB');
                return false;
            }

            await this.restoreSshFolder(result);

            let projectBufferBase64 = result.dataValues.projectsfolderdetails;

            console.log("Projects folder metadata found in DB,Restoring the projects folder");

            var archivedFolderBuffer = Buffer.from(projectBufferBase64, 'base64');

            isCreated = await folders.createZippedFolder(zipFolderPath, archivedFolderBuffer);

            if (!isCreated) {
                console.error('ProjectsService - restoreProjectsFolder() - Unable to create Zipped Folder for projects', e);
                return;
            }

            let isUnzipped = await folders.unzipFolder(zipFolderPath, extractToFolderPath, false);

            if (!isUnzipped) {
                return isUnzipped;
            }

            console.log('Projects folder was successfully restored');
            return true;
        }
        catch (e) {
            console.error('ProjectsService - restoreProjectsFolder() - Unable to restore projects folder', e);
            return false;
        } finally {
            folders.removeFolderOrFile(isCreated, zipFolderPath);
        }
    }

    async restoreSshFolder(result) {

        let rootFolderPath = this._rootFolderPath;

        let zipFolderPath = path.join(rootFolderPath, "ssh.zip");
        let extractToFolderPath = path.join(rootFolderPath, ".ssh");
        let isCreated = false;

        try {      
            let sshBufferBase64 = result.dataValues.sshfolderdetails;

            if (!sshBufferBase64) {
                await this.createSshFolder();
                console.warn('ProjectsService - restoreSshFolder() - SSH folder metadata not found in DB');
                return;
            }

            console.log("SSH folder metadata found in DB,Restoring the ssh folder");

            var archivedFolderBuffer = Buffer.from(sshBufferBase64, 'base64');

            isCreated = await folders.createZippedFolder(zipFolderPath, archivedFolderBuffer);

            if (!isCreated) {
                console.error('ProjectsService - restoreSshFolder() - Unable to create Zipped Folder for ssh', e);
                return;
            }

            //send false because files are saved to root folder in zip file
            let isUnzipped = await folders.unzipFolder(zipFolderPath, extractToFolderPath, false);

            if (!isUnzipped) {
                return isUnzipped;
            }

            console.log('Projects folder was successfully restored');
            return true;
        }
        catch (e) {
            console.error('ProjectsService - restoreSshFolder() - Unable to restore projects folder', e);
            return false;
        } finally {
            folders.removeFolderOrFile(isCreated, zipFolderPath);
        }
    }

    async createSshFolder() {
        console.log('Checking if SSH folder is created or not');

        let rootFolderPath = this._rootFolderPath;

        let sshFolderPath = path.join(rootFolderPath, ".ssh");
        await folders.createFolder(sshFolderPath)

        let knownHostsFolderPath = path.join(rootFolderPath, ".ssh", "known_hosts");
        await folders.createFile(knownHostsFolderPath)
    }
}

export default ProjectsService;

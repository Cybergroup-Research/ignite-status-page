import ProjectsDetails from '../models/projectDetails';
import IgniteMetadeta from '../models/igniteMetadeta';


function init() {
    this.defaultUniqueClientID = 'b4c117ed-9e9c-41d8-aae5-361c32359be1';
}

/** while archiving config file if directoryDestPath is true then set extractFromSubFolders argument to true */
async function saveBufferConfigInDB(bufferConfigBase64, extractFromSubFolders) {
    try {
        console.log("Upserting config metadata in DB");

        let insertQuery = `INSERT INTO ignitemetadata (metadataname,folderdetails,extractfromsubfolders) SELECT 'config','${bufferConfigBase64}',${extractFromSubFolders} WHERE NOT EXISTS (select * from ignitemetadata where metadataname = 'config');`;
        let updateQuery = `UPDATE ignitemetadata SET folderdetails = '${bufferConfigBase64}', extractfromsubfolders = ${extractFromSubFolders}, updated_date = CURRENT_TIMESTAMP WHERE metadataname = 'config';`;

        let result = await upsertIgniteMetadataInDB(updateQuery + insertQuery);

        let rowsUpserted = result.rowCount;
        let command = result.command.toLowerCase() === 'insert' ? 'inserted' : 'updated';

        console.log(`Config metadata was successfully ${command}, number of rows ${command} = ${rowsUpserted}`);

        return rowsUpserted === 1;

    } catch (e) {
        console.error(e);
        return false;
    }
}

/** while archiving package json if directoryDestPath is true then set extractFromSubFolders argument to true */
async function saveBufferPackagesInDB(bufferPackagesBase64, extractFromSubFolders) {
    try {
        console.log("Upserting Package metadata in DB");

        let insertQuery = `INSERT INTO ignitemetadata (metadataname,folderdetails,extractfromsubfolders) SELECT 'package','${bufferPackagesBase64}',${extractFromSubFolders} WHERE NOT EXISTS (select * from ignitemetadata where metadataname = 'package');`;
        let updateQuery = `UPDATE ignitemetadata SET folderdetails = '${bufferPackagesBase64}', extractfromsubfolders = ${extractFromSubFolders}, updated_date = CURRENT_TIMESTAMP WHERE metadataname = 'package';`;

        let result = await upsertIgniteMetadataInDB(updateQuery + insertQuery);

        let rowsUpserted = result.rowCount;
        let command = result.command.toLowerCase() === 'insert' ? 'inserted' : 'updated';

        console.log(`Package metadata was successfully ${command}, number of rows ${command} = ${rowsUpserted}`);

        return rowsUpserted === 1;

    } catch (e) {
        console.error(e);
        return false;
    }
}


/** while archiving node_modules folder if directoryDestPath is true then set extractFromSubFolders argument to true */
async function saveBufferNodeModulesInDB(bufferNodeModulesBase64, extractFromSubFolders) {
    try {
        console.log("Upserting NodeModules metadata in DB");

        let insertQuery = `INSERT INTO ignitemetadata (metadataname,folderdetails,extractfromsubfolders) SELECT 'node_modules','${bufferNodeModulesBase64}',${extractFromSubFolders} WHERE NOT EXISTS (select * from ignitemetadata where metadataname = 'node_modules');`;
        let updateQuery = `UPDATE ignitemetadata SET folderdetails = '${bufferNodeModulesBase64}', extractfromsubfolders = ${extractFromSubFolders}, updated_date = CURRENT_TIMESTAMP WHERE metadataname = 'node_modules';`;

        let result = await upsertIgniteMetadataInDB(updateQuery + insertQuery);

        let rowsUpserted = result.rowCount;
        let command = result.command.toLowerCase() == 'insert' ? 'inserted' : 'updated';

        console.log(`NodeModules metadata was successfully ${command}, number of rows ${command} = ${rowsUpserted}`);

        return rowsUpserted === 1;

    } catch (e) {
        console.error(e);
        return false;
    }
}

/** while archiving library folder if directoryDestPath is true then set extractFromSubFolders argument to true */
async function saveBufferLibInDB(bufferLibBase64, extractFromSubFolders) {
    try {
        console.log("Upserting Functions metadata in DB");

        let insertQuery = `INSERT INTO ignitemetadata (metadataname,folderdetails,extractfromsubfolders) SELECT 'lib','${bufferLibBase64}',${extractFromSubFolders} WHERE NOT EXISTS (select * from ignitemetadata where metadataname = 'lib');`;
        let updateQuery = `UPDATE ignitemetadata SET folderdetails = '${bufferLibBase64}', extractfromsubfolders = ${extractFromSubFolders}, updated_date = CURRENT_TIMESTAMP WHERE metadataname = 'lib';`;

        let result = await upsertIgniteMetadataInDB(updateQuery + insertQuery);

        let rowsUpserted = result.rowCount;
        let command = result.command.toLowerCase() === 'insert' ? 'inserted' : 'updated';

        console.log(`Lib/Functions metadata was successfully ${command}, number of rows ${command} = ${rowsUpserted}`);

        return rowsUpserted === 1;

    } catch (e) {
        console.error(e);
        return false;
    }
}

async function saveBinaryProjectsInDB(projectsBinaryBase64) {
    try {
        console.log("Upserting projects in DB");

        let insertQuery = `INSERT INTO projectDetails (clientid,projectsFolderDetails) SELECT '${this.defaultUniqueClientID}','${projectsBinaryBase64}' WHERE NOT EXISTS (select * from projectDetails where clientid = '${this.defaultUniqueClientID}');`;
        let updateQuery = `UPDATE projectDetails SET projectsFolderDetails = '${projectsBinaryBase64}', updated_date = CURRENT_TIMESTAMP WHERE clientid = '${this.defaultUniqueClientID}';`;

        let result = await upsertProjectsInDB(updateQuery + insertQuery);

        let rowsUpserted = result.rowCount;
        let command = result.command.toLowerCase() == 'insert' ? 'inserted' : 'updated';

        console.log(`Projects successfully ${command}, number of rows ${command} = ${rowsUpserted}`);

        return rowsUpserted === 1;

    } catch (e) {
        console.error(e);
        return false;
    }
}

async function saveBinarySSHInDB(sshBinaryBase64) {
    try {
        console.log("Upserting ssh folder in DB");

        let insertQuery = `INSERT INTO projectDetails (clientid,sshfolderdetails) SELECT '${this.defaultUniqueClientID}','${sshBinaryBase64}' WHERE NOT EXISTS (select * from projectDetails where clientid = '${this.defaultUniqueClientID}');`;
        let updateQuery = `UPDATE projectDetails SET sshfolderdetails = '${sshBinaryBase64}', updated_date = CURRENT_TIMESTAMP WHERE clientid = '${this.defaultUniqueClientID}';`;

        let result = await upsertProjectsInDB(updateQuery + insertQuery);

        let rowsUpserted = result.rowCount;
        let command = result.command.toLowerCase() == 'insert' ? 'inserted' : 'updated';

        console.log(`SSH successfully ${command}, number of rows ${command} = ${rowsUpserted}`);

        return rowsUpserted === 1;

    } catch (e) {
        console.error(e);
        return false;
    }
}

async function upsertIgniteMetadataInDB(query) {

    let igniteMetadeta = new IgniteMetadeta();
    try {
        console.log("Upserting metadata in DB");

        let sequelizeConnection = igniteMetadeta.sequelizeConnection;

        let rows = await sequelizeConnection.query(query);

        let result = rows[1].filter(x => x.rowCount == 1).shift();

        return result;

    } catch (e) {
        console.error(e);
        return false;
    } finally {
        igniteMetadeta.sequelizeConnection.close();
    }
}

async function upsertProjectsInDB(query) {

    let projectDetails = new ProjectsDetails();
    try {
        console.log("Upserting projects in DB");

        let sequelizeConnection = projectDetails.sequelizeConnection;

        let rows = await sequelizeConnection.query(query);

        let result = rows[1].filter(x => x.rowCount == 1).shift();

        return result;

    } catch (e) {
        console.error(e);
        return false;
    } finally {
        projectDetails.sequelizeConnection.close();
    }
}

async function getIgniteMetaDataFromDB() {
    let igniteMetadeta = new IgniteMetadeta();
    try {
        let igniteMetadetaSchema = igniteMetadeta.igniteMetadetaSchema;

        var result = await igniteMetadetaSchema.findAll({ raw: true });

        return result;
    } catch (e) {
        console.error(e);
        return null;
    } finally {
        igniteMetadeta.sequelizeConnection.close();
    }
}

async function getProjectsFromDB() {
    let projectDetails = new ProjectsDetails();
    try {
        let projectDetailsSchema = projectDetails.projectDetailsSchema;

        var result = await projectDetailsSchema.findOne({ attributes: ['projectsfolderdetails','sshfolderdetails'], where: { clientid: `${this.defaultUniqueClientID}` } });

        return result;
    } catch (e) {
        console.error(e);
        return null;
    } finally {
        projectDetails.sequelizeConnection.close();
    }
}

module.exports = {
    init: init,
    saveBinaryProjectsInDB: saveBinaryProjectsInDB,
    getProjectsFromDB: getProjectsFromDB,
    saveBinarySSHInDB: saveBinarySSHInDB,
    saveBufferConfigInDB: saveBufferConfigInDB,
    getIgniteMetaDataFromDB: getIgniteMetaDataFromDB,
    saveBufferNodeModulesInDB: saveBufferNodeModulesInDB,
    saveBufferPackagesInDB: saveBufferPackagesInDB,
    saveBufferLibInDB: saveBufferLibInDB
};
